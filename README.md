## 1. 전체 프로젝트 설명

 플레이어는 "스파르타 마을"이라는 가상의 공간에서 아이템을 구매하거나, 인벤토리를 관리하고, 자신의 상태를 확인할 수 있습니다. 이 게임은 텍스트 기반으로 상호작용하며, 사용자의 입력을 통해 다양한 화면 전환 및 아이템 구매와 같은 기능이 작동합니다.

게임의 주요 흐름은 **로비 → 상태 확인 / 인벤토리 관리 / 상점** 의 사이클로 이루어져 있으며, 각 기능은 `Game` 클래스에서 처리됩니다.

 프로그램의 전체 구조는 인프런 Rookiss 강사님의 [C#과 유니티로 만드는 MMORPG 게임 개발 시리즈] Part1: C# 기초 프로그래밍 입문 강의 TextRPG2의 코드를 참고하여 구현했습니다.

---

## 2. 각 소스 파일의 역할 및 클래스 설명

### `Program.cs`

- **역할**: 프로그램의 진입점(Main 메서드)을 포함. 게임을 실행하기 위한 루프를 설정하며, 일정한 시간마다 `Game` 클래스의 `Process` 메서드를 호출하여 게임의 진행을 처리.
- **클래스**: `Program`
    - **Main 함수**: 게임의 메인 루프를 실행하여 지속적으로 `Game.Process`를 호출하고, 게임의 상태를 처리.

### `Game.cs`

- **역할**: 게임의 주요 흐름을 제어하는 핵심 클래스. 로비에서의 화면 처리, 상태 확인, 인벤토리 관리, 상점에서의 아이템 구매 등을 담당. Unity에서의 GameManager와 같은 역할.
- **클래스**: `Game`
    - **Process** : 게임의 현재 상태에 따라 적절한 처리 함수를 호출
    - **ProcessLobby** : 로비 화면을 처리하고 사용자의 선택에 따라 게임 모드를 전환
    - **ProcessShowState** : 플레이어의 상태 보기
    - **ProcessShowInven** : 인벤토리 보기
    - **ProcessEquipItem** : 아이템 장착 관리
    - **ProcessGoStore** : 상점 관리
    - **ProcessGoShelter** :  휴식 하기
    - **ProcessBuyItem** : 아이템 구매 관리
    - **ProcessSellItem** : 아이템 판매 관리

### `Player.cs`

- **역할**: 플레이어의 정보를 관리하는 클래스. 플레이어의 레벨, 공격력, 방어력, HP, 골드 등의 상태 정보를 저장하고, 상태 확인 화면을 처리
- **클래스**: `Player`
    - **ProcessShowState** : 플레이어의 상태를 화면에 출력
    - **ProcessGoShelter** : 플레이어가 휴식할 수 있도록 관리
    - **ProcessRest** : 휴식 요청의 유효성 체크 및 휴식 실행
    - **프로퍼티**: 플레이어의 상태(레벨, 공격력, 방어력 등)를 관리

### `Item.cs`

- **역할**: 게임 내 아이템을 정의하는 클래스. 기본 아이템, 공격 아이템, 방어 아이템의 속성 정의
- **클래스**: `Item`, `AttackItem`, `DefenseItem`
    - **AttackItem**: 공격력을 제공하는 아이템
    - **DefenseItem**: 방어력을 제공하는 아이템

### `Store.cs`

- **역할**: 상점에서 아이템을 구매하고, 아이템 목록을 표시하는 역할을 담당하는 클래스
- **클래스**: `Store`
    - **ProcessGoStore** : 상점 화면 출력
    - **ProcessBuyItem** : 아이템 구매 화면 처리, 사용자의 선택에 따라 구매 처리를 진행
    - **ProcessSellItem** : 아이템 구매 화면 처리, 사용자의 선택에 따라 구매 처리를 진행
    - **CheckBuying** : 선택한 아이템의 구매 유효성 확인 및 구매 처리
    - **CheckSelling** : 선택한 아이템의 판매 유효성 확인 및 판매 처리

### `Inventory.cs`

- **역할**: 플레이어의 인벤토리를 관리하는 클래스. 보유한 아이템의 목록을 보여주고, 아이템 장착 및 해제할 수 있는 기능을 제공
- **클래스**: `Inventory`
    - **ProcessShowInven** : 인벤토리 화면 출력
    - **ProcessEquipItem** : 아이템 장착 관리 화면 출력
    - **EquipItem** : 선택한 아이템을 장착 또는 해제하고, 플레이어의 공격력이나 방어력에 반영

### `Utility.cs`

- **역할**: 게임 전반에서 공통으로 사용되는 유틸리티 기능들을 제공하는 클래스. 사용자 입력을 처리하거나, 한글과 영어의 문자열 너비를 맞추는 등의 기능을 수행.
- **클래스**: `Utility`
    - **InputFromUser** : 사용자로부터 입력을 받아 유효성 검사하고 메시지 출력
    - **PrintItemList** : 호출한 프로세스에 따라 상황에 맞는 아이템 목록을 화면에 출력
    - **AlignWidth** : 한글과 영어 문자의 너비를 계산하여 출력 정렬에 사용
    - **PadRightWithVisualWidth** : 주어진 너비에 맞춰 텍스트를 오른쪽을 패딩

---

## 3. 장점 및 단점

### 장점

1. **구조적 설계**: 게임의 각 기능이 서로 독립적으로 구현되어 있어, 유지보수 및 기능 확장이 용이
2. **객체 지향적 구성**: 플레이어, 아이템, 상점, 인벤토리 등 객체 지향적인 구조로 설계되어 있어, 게임의 다양한 요소를 쉽게 관리 가능

### 단점

1. **중복 코드**: 아이템 목록 출력, 아이템 장착/해제 로직 등 여러 파일에 걸쳐 유사한 코드가 반복
2. **확장성 부족**: 현재는 한 명의 플레이어와 단순한 상점, 인벤토리 기능만을 지원. 이를 다중 플레이어로 확장하거나 던전 탐험 등의 기능을 추가하려면 구조적인 개선이 필요.

---

## 4. 개선 방안

1. **코드 중복 제거**: `Utility` 클래스에 아이템 출력이나 장착/해제와 같은 공통 기능을 추가해 중복 코드를 줄이기
2. **구조 확장**: 향후 기능 확장을 고려하여, 플레이어 클래스의 직업 타입을 enum 으로 설정하는 대신 Player 클래스를 부모로 만들고 Warrior를 자식 클래스로 상속하도록 구조 변경

---
## 5. 패치 노트

- **Player 구조 리팩토링**

<aside>

>> **기존 구조**   
 Player의 필드로 job을 enum 값으로 설정   
 **변경 구조**   
 Player 부모 클래스를 상속하는 Warrior 클래스 생성   
 Player 클래스의 job 필드 삭제           
 Item과 Player의 클래스의 경우 상속하는 부모 클래스가 직접 인스턴스 생성하지 않도록   
>> 생성자의 접근제한자를 **public → protected** 로 변경

</aside>

- **새로운 아이템 추가**
- **휴식하기 기능 추가**
- **아이템 판매 기능 추가**
- **아이템 출력 구조 리팩토링**

<aside>

>> 반복되는 아이템 출력 코드를 Utility.cs에 PrintItemList() 메소드로 선언해 사용    
>> PrintType과 List<Item>을 매개변수로 하여 각 화면과 출력 해야 할 아이템 목록에 따라 다르게 동작하도록 설정

</aside>
